# Polling Script Template

When `POST /proxy` returns 428, write and execute a polling script that:
1. Polls until a terminal status is reached
2. Executes the approved request
3. Re-invokes the original agent with the result **and the original request context**

## Python template

```python
#!/usr/bin/env python3
"""
GaiterGuard approval polling script.
Generated by agent after receiving HTTP 428 from POST /proxy.

Replace PLACEHOLDER values before running.
"""
import time, json, subprocess, sys
import urllib.request, urllib.error

GATEWAY_URL = "PLACEHOLDER_GATEWAY_URL"   # e.g. http://localhost:3000
AGENT_KEY   = "PLACEHOLDER_AGENT_KEY"    # agt_...
ACTION_ID   = "PLACEHOLDER_ACTION_ID"    # UUID from 428 response

# The original request that was blocked — fill these in from the 428 context.
# This is passed back to the agent on re-invoke so it has full context of what was executed.
ORIGINAL_REQUEST = {
    "targetUrl":      "PLACEHOLDER_TARGET_URL",    # the URL that was blocked
    "method":         "PLACEHOLDER_METHOD",         # GET, POST, DELETE, etc.
    "intent":         "PLACEHOLDER_INTENT",         # the intent string you sent
    "body":           "PLACEHOLDER_BODY",           # the body you sent (or None)
    "idempotencyKey": "PLACEHOLDER_IDEMPOTENCY_KEY",
    # From the 428 response body:
    "riskScore":      0.0,                          # PLACEHOLDER_RISK_SCORE
    "riskExplanation": "PLACEHOLDER_RISK_EXPLANATION",
}

POLL_INTERVAL = 8   # seconds between polls
MAX_POLLS     = 75  # ~10 minutes total before giving up


def request(method, path, body=None):
    url = f"{GATEWAY_URL}{path}"
    data = json.dumps(body).encode() if body else None
    headers = {
        "Agent-Key":    AGENT_KEY,
        "Content-Type": "application/json",
    }
    req = urllib.request.Request(url, data=data, headers=headers, method=method)
    try:
        with urllib.request.urlopen(req) as r:
            return r.status, json.loads(r.read())
    except urllib.error.HTTPError as e:
        return e.code, json.loads(e.read())


def poll():
    print(f"[gaiterguard] Polling for approval: {ACTION_ID}")
    for attempt in range(MAX_POLLS):
        status_code, body = request("GET", f"/status/{ACTION_ID}")

        if status_code != 200:
            print(f"[gaiterguard] Status poll error {status_code}: {body}")
            time.sleep(POLL_INTERVAL)
            continue

        state = body.get("status")
        print(f"[gaiterguard] Attempt {attempt + 1}: {state}")

        if state == "PENDING":
            time.sleep(POLL_INTERVAL)
            continue

        if state == "DENIED":
            print("[gaiterguard] Request denied by human reviewer.")
            return {
                "outcome": "denied",
                "resolved_at": body.get("resolved_at"),
                "original_request": ORIGINAL_REQUEST,
            }

        if state == "EXPIRED":
            print("[gaiterguard] Approval window expired.")
            return {
                "outcome": "expired",
                "original_request": ORIGINAL_REQUEST,
            }

        if state == "APPROVED":
            print("[gaiterguard] Approved — executing request...")
            exec_code, exec_body = request("POST", f"/proxy/execute/{ACTION_ID}")
            if exec_code in (200, 201, 202, 204):
                print(f"[gaiterguard] Executed successfully (HTTP {exec_code}).")
                return {
                    "outcome": "executed",
                    "status": exec_code,
                    "body": exec_body,
                    "original_request": ORIGINAL_REQUEST,
                }
            elif exec_code == 410:
                print("[gaiterguard] Approval expired before execution.")
                return {
                    "outcome": "expired",
                    "original_request": ORIGINAL_REQUEST,
                }
            else:
                print(f"[gaiterguard] Execute failed (HTTP {exec_code}): {exec_body}")
                return {
                    "outcome": "error",
                    "status": exec_code,
                    "body": exec_body,
                    "original_request": ORIGINAL_REQUEST,
                }

        if state == "EXECUTED":
            # Already executed (e.g., concurrent poll resolved it)
            result = body.get("result", {})
            print(f"[gaiterguard] Already executed (upstream HTTP {result.get('status')}).")
            return {
                "outcome": "executed",
                "status": result.get("status"),
                "body": result.get("body"),
                "original_request": ORIGINAL_REQUEST,
            }

        print(f"[gaiterguard] Unknown state: {state}")
        time.sleep(POLL_INTERVAL)

    print("[gaiterguard] Max polls reached — giving up.")
    return {
        "outcome": "timeout",
        "original_request": ORIGINAL_REQUEST,
    }


def re_invoke_agent(result):
    """
    Re-invoke the original agent process with the gateway result AND original request context.
    The agent receives:
      result["outcome"]          — "executed" | "denied" | "expired" | "error" | "timeout"
      result["status"]           — upstream HTTP status (if executed)
      result["body"]             — upstream response body (if executed)
      result["original_request"] — the original blocked request + risk context

    Replace the subprocess call with however your agent is invoked.

    Examples:
      subprocess.run(["claude", "--print", json.dumps(result)], check=True)
      subprocess.run(["python", "my_agent.py", "--result", json.dumps(result)], check=True)
    """
    payload = json.dumps(result, indent=2)
    print(f"[gaiterguard] Invoking agent with result:\n{payload}")
    # PLACEHOLDER: replace with your agent invocation command
    # subprocess.run(["AGENT_COMMAND", payload], check=True)


if __name__ == "__main__":
    result = poll()
    if result.get("outcome") == "executed":
        re_invoke_agent(result)
    else:
        print(f"[gaiterguard] Final outcome: {json.dumps(result, indent=2)}")
        sys.exit(1)
```

## Shell (curl) template

```bash
#!/usr/bin/env bash
GATEWAY_URL="PLACEHOLDER_GATEWAY_URL"
AGENT_KEY="PLACEHOLDER_AGENT_KEY"
ACTION_ID="PLACEHOLDER_ACTION_ID"

# Original blocked request context — fill in from the 428 response
ORIGINAL_TARGET_URL="PLACEHOLDER_TARGET_URL"
ORIGINAL_METHOD="PLACEHOLDER_METHOD"
ORIGINAL_INTENT="PLACEHOLDER_INTENT"
ORIGINAL_RISK_SCORE="PLACEHOLDER_RISK_SCORE"
ORIGINAL_RISK_EXPLANATION="PLACEHOLDER_RISK_EXPLANATION"

poll() {
  while true; do
    RESPONSE=$(curl -s -H "Agent-Key: $AGENT_KEY" "$GATEWAY_URL/status/$ACTION_ID")
    STATE=$(echo "$RESPONSE" | python3 -c "import sys,json; print(json.load(sys.stdin)['status'])")

    case "$STATE" in
      PENDING)  echo "Pending... waiting"; sleep 8 ;;
      APPROVED)
        echo "Approved — executing"
        RESULT=$(curl -s -X POST -H "Agent-Key: $AGENT_KEY" "$GATEWAY_URL/proxy/execute/$ACTION_ID")
        PAYLOAD=$(python3 -c "
import json, sys
result = json.loads('$RESULT')
original = {
  'targetUrl': '$ORIGINAL_TARGET_URL',
  'method': '$ORIGINAL_METHOD',
  'intent': '$ORIGINAL_INTENT',
  'riskScore': $ORIGINAL_RISK_SCORE,
  'riskExplanation': '$ORIGINAL_RISK_EXPLANATION',
}
print(json.dumps({'outcome': 'executed', 'result': result, 'original_request': original}))
")
        echo "$PAYLOAD"
        # Re-invoke agent with full context: e.g., claude --print "$PAYLOAD"
        exit 0
        ;;
      EXECUTED)
        RESULT=$(echo "$RESPONSE" | python3 -c "
import sys,json
d=json.load(sys.stdin)
original = {
  'targetUrl': '$ORIGINAL_TARGET_URL',
  'method': '$ORIGINAL_METHOD',
  'intent': '$ORIGINAL_INTENT',
  'riskScore': $ORIGINAL_RISK_SCORE,
  'riskExplanation': '$ORIGINAL_RISK_EXPLANATION',
}
print(json.dumps({'outcome': 'executed', 'result': d.get('result',{}), 'original_request': original}))
")
        echo "Already executed: $RESULT"
        # Re-invoke agent here
        exit 0
        ;;
      DENIED)
        echo "Denied — original request: $ORIGINAL_TARGET_URL [$ORIGINAL_METHOD]"
        # Re-invoke agent with denial context if needed
        exit 1
        ;;
      EXPIRED)  echo "Expired — resubmit via POST /proxy"; exit 1 ;;
      *)        echo "Unknown state: $STATE"; exit 1 ;;
    esac
  done
}

poll
```

## Key implementation notes

- **Always include original request context** when re-invoking. The agent resumes mid-task and
  needs to know what was approved and executed (URL, method, intent, risk score/explanation) to
  continue correctly, especially if multiple requests were blocked in the same session.
- **Fill in ORIGINAL_REQUEST from the 428 response** — `action_id`, `risk_score`,
  `risk_explanation` come from the 428 body; `targetUrl`, `method`, `intent`, `body`,
  `idempotencyKey` come from the original `POST /proxy` request the agent made.
- **Execution is separate from approval.** `APPROVED` status means a human approved it; the agent
  still must call `POST /proxy/execute/{action_id}` to actually run the request.
- **`EXECUTED` status** means the request already ran (e.g., you hit the status endpoint after
  execution). Read `result.body` directly — no need to call execute again.
- **Idempotency:** The execute endpoint is safe to retry on network errors — the gateway uses
  conditional status transitions to prevent double execution.
- **Expiry:** Approved requests expire if not executed promptly. If you get a 410 from execute,
  resubmit the original request via `POST /proxy`.
