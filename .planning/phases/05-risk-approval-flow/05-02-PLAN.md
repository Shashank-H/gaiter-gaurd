---
phase: 05-risk-approval-flow
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - backend/src/services/proxy.service.ts
  - backend/src/routes/proxy.ts
  - backend/src/routes/approval.ts
  - backend/src/server.ts
autonomous: true

must_haves:
  truths:
    - "Risky requests to POST /proxy return 428 with action_id instead of forwarding"
    - "Blocked requests are stored in approval_queue with full context and risk assessment"
    - "Agent can poll GET /status/{action_id} and receive current status"
    - "Agent can execute approved requests via POST /proxy/execute/{action_id}"
    - "Executed responses are cached and returned on subsequent status polls"
    - "TTL cleanup job expires stale approved requests"
  artifacts:
    - path: "backend/src/services/proxy.service.ts"
      provides: "RiskyRequestError class and risk gate in executeProxyRequest"
      contains: "RiskyRequestError"
    - path: "backend/src/routes/proxy.ts"
      provides: "428 response handling and POST /proxy/execute/:actionId handler"
      exports: ["handleProxy", "handleProxyExecute"]
    - path: "backend/src/routes/approval.ts"
      provides: "GET /status/:actionId polling handler"
      exports: ["handleApprovalStatus"]
    - path: "backend/src/server.ts"
      provides: "Route wiring for status and execute endpoints, TTL cleanup interval"
      contains: "handleApprovalStatus"
  key_links:
    - from: "backend/src/services/proxy.service.ts"
      to: "backend/src/services/risk.service.ts"
      via: "assessRisk() call inside executeProxyRequest"
      pattern: "assessRisk"
    - from: "backend/src/services/proxy.service.ts"
      to: "backend/src/services/approval.service.ts"
      via: "createApprovalQueueEntry() on risky request"
      pattern: "createApprovalQueueEntry"
    - from: "backend/src/routes/proxy.ts"
      to: "backend/src/services/proxy.service.ts"
      via: "catch RiskyRequestError -> 428 response"
      pattern: "RiskyRequestError"
    - from: "backend/src/routes/approval.ts"
      to: "backend/src/services/approval.service.ts"
      via: "getApprovalQueueEntry in status handler"
      pattern: "getApprovalQueueEntry"
    - from: "backend/src/server.ts"
      to: "backend/src/routes/approval.ts"
      via: "regex route match for /status/:actionId"
      pattern: "handleApprovalStatus"
---

<objective>
Wire the risk assessment gate into the proxy flow, handle 428 blocking responses, create the status polling endpoint and execute endpoint, and start the TTL cleanup job.

Purpose: This completes the risk & approval flow — agents hitting risky operations get blocked, can poll for resolution, and execute approved requests.
Output: Modified proxy service/route, new approval route, updated server.ts with new routes and TTL cleanup.
</objective>

<execution_context>
@/home/shashank/.claude/get-shit-done/workflows/execute-plan.md
@/home/shashank/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-risk-approval-flow/05-RESEARCH.md
@.planning/phases/05-risk-approval-flow/05-01-SUMMARY.md
@backend/src/services/proxy.service.ts
@backend/src/routes/proxy.ts
@backend/src/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate risk gate into proxy service and route handler</name>
  <files>backend/src/services/proxy.service.ts, backend/src/routes/proxy.ts</files>
  <action>
**1. Add RiskyRequestError to backend/src/services/proxy.service.ts:**

Add a new error class (alongside existing ProxyError, NotFoundError, ForbiddenError):
```typescript
export class RiskyRequestError extends Error {
  statusCode = 428;
  constructor(
    public actionId: string,
    public riskScore: number,
    public riskExplanation: string
  ) {
    super('Request requires human approval');
    this.name = 'RiskyRequestError';
  }
}
```

**2. Add risk gate to executeProxyRequest() in proxy.service.ts:**

Import `assessRisk` from '@/services/risk.service' and `createApprovalQueueEntry` from '@/services/approval.service'.

Insert the risk assessment step AFTER step 2 (validateTargetUrl) and BEFORE step 3 (idempotency check). This position is per research Pattern 1 — risk check happens before idempotency because a risky request should be blocked regardless of caching.

New step between existing steps 2 and 3:
```
// Step 2.5: Risk assessment gate
const riskResult = await assessRisk({
  intent: data.intent,
  method: data.method,
  targetUrl: data.targetUrl,
  body: data.body ?? null,
});

if (riskResult.blocked) {
  // Strip auth-related headers before storing (pitfall #1)
  const safeHeaders = { ...data.headers };
  delete safeHeaders['Authorization'];
  delete safeHeaders['authorization'];
  delete safeHeaders['Agent-Key'];
  delete safeHeaders['agent-key'];

  const actionId = await createApprovalQueueEntry({
    agentId,
    serviceId: service.id,
    method: data.method,
    targetUrl: data.targetUrl,
    requestHeaders: safeHeaders,
    requestBody: data.body ?? null,
    intent: data.intent,
    riskScore: riskResult.score,
    riskExplanation: riskResult.explanation,
  });
  throw new RiskyRequestError(actionId, riskResult.score, riskResult.explanation);
}
```

Keep the existing numbering comments (Step 3, 4, 5...) but update the comment numbers if desired for clarity.

**3. Handle RiskyRequestError in backend/src/routes/proxy.ts:**

Import `RiskyRequestError` from '@/services/proxy.service'.

In the catch block of handleProxy, add a handler BEFORE the generic ProxyError handler:
```typescript
if (error instanceof RiskyRequestError) {
  return Response.json(
    {
      error: 'Request requires human approval',
      action_id: error.actionId,
      risk_score: error.riskScore,
      risk_explanation: error.riskExplanation,
      status_url: `/status/${error.actionId}`,
    },
    { status: 428 }
  );
}
```

This returns the action_id in the 428 body so the agent knows where to poll (pitfall #4).
  </action>
  <verify>
TypeScript compilation: `cd /home/shashank/personal/gaiter-gaurd/backend && bunx tsc --noEmit src/services/proxy.service.ts src/routes/proxy.ts` has no errors. Verify RiskyRequestError is exported: `bun -e "import { RiskyRequestError } from './src/services/proxy.service'; console.log(new RiskyRequestError('test-id', 0.8, 'test').statusCode)"` prints 428.
  </verify>
  <done>executeProxyRequest() calls assessRisk() after URL validation; risky requests create an approval queue entry and throw RiskyRequestError. The proxy route handler catches RiskyRequestError and returns 428 with action_id, risk_score, risk_explanation, and status_url.</done>
</task>

<task type="auto">
  <name>Task 2: Status polling route, execute route, and server wiring</name>
  <files>backend/src/routes/approval.ts, backend/src/routes/proxy.ts, backend/src/server.ts</files>
  <action>
**1. Create backend/src/routes/approval.ts — GET /status/:actionId handler:**

Import `requireAgentAuth`, `AuthError` from '@/middleware/auth'. Import `getApprovalQueueEntry` from '@/services/approval.service'. Import `errorResponse` from '@/utils/responses'.

Export `handleApprovalStatus(req: Request, params: { actionId: string }): Promise<Response>`:
- Authenticate agent via requireAgentAuth(req) — get agentId
- Call getApprovalQueueEntry(params.actionId)
- If null: return errorResponse('Action not found', 404)
- If row.agentId !== agentId: return errorResponse('Action not found', 404) — don't reveal existence to other agents
- Return different shapes based on status (per research Pattern 5):
  - PENDING: `{ status: 'PENDING', action_id, created_at: row.createdAt.toISOString() }`
  - APPROVED: `{ status: 'APPROVED', action_id, execute_url: '/proxy/execute/${action_id}' }`
  - DENIED: `{ status: 'DENIED', action_id, resolved_at: row.resolvedAt?.toISOString() }`
  - EXPIRED: `{ status: 'EXPIRED', action_id }`
  - EXECUTED: `{ status: 'EXECUTED', action_id, result: { status: row.responseStatus, headers: JSON.parse(row.responseHeaders || '{}'), body: row.responseBody } }`
- Wrap in try/catch for AuthError handling (same pattern as proxy.ts)

**2. Add handleProxyExecute to backend/src/routes/proxy.ts:**

Import `getApprovalQueueEntry`, `markExecuted` from '@/services/approval.service'. Import `injectCredentials`, `forwardRequest`, `resolveService` from '@/services/proxy.service' (resolveService may not be needed since we have serviceId stored).

Export `handleProxyExecute(req: Request, params: { actionId: string }): Promise<Response>`:
- Authenticate agent via requireAgentAuth(req) — get agentId, userId
- Get approval queue entry by actionId
- If null: return errorResponse('Action not found', 404)
- If row.agentId !== agentId: return errorResponse('Action not found', 404)
- If row.status !== 'APPROVED': return errorResponse(`Cannot execute action with status ${row.status}`, 409)
- Check TTL: if row.approvalExpiresAt && row.approvalExpiresAt < new Date():
  - Import transitionStatus, call transitionStatus(actionId, 'APPROVED', 'EXPIRED') fire-and-forget
  - Return errorResponse('Approval has expired — resubmit request via POST /proxy', 410)
- Reconstruct and execute the stored request:
  - Get service credentials: query the services table for row.serviceId to get authType, or store authType in approval_queue... Actually, we need the service record. Query: `db.select().from(services).where(eq(services.id, row.serviceId)).limit(1)`
  - If service not found: return errorResponse('Service no longer exists', 410)
  - Parse stored headers: `JSON.parse(row.requestHeaders || '{}')`
  - Inject credentials: `await injectCredentials(parsedHeaders, row.serviceId, service.authType)`
  - Forward request: `await forwardRequest(row.targetUrl, row.method, headersWithCreds, row.requestBody)`
  - Store result: `await markExecuted(actionId, response.status, response.headers, response.body)`
  - Return the response with same formatting as handleProxy (Content-Type passthrough, X-Proxy-Status: 'executed-approved')
- Wrap in try/catch handling AuthError, ProxyError, and generic errors

**3. Update backend/src/server.ts — wire new routes + TTL cleanup:**

Add imports:
```typescript
import { handleApprovalStatus } from '@/routes/approval';
import { handleProxyExecute } from '@/routes/proxy';
import { expireStaleApprovals } from '@/services/approval.service';
```

Add route matching in handleRequest() AFTER the existing /proxy block and BEFORE the "Check if path exists" block:

```typescript
// GET /status/:actionId — agent polls for approval status
const statusMatch = pathname.match(/^\/status\/([0-9a-f-]{36})$/);
if (statusMatch && method === 'GET') {
  return await handleApprovalStatus(req, { actionId: statusMatch[1] });
}

// POST /proxy/execute/:actionId — agent executes approved request
const executeMatch = pathname.match(/^\/proxy\/execute\/([0-9a-f-]{36})$/);
if (executeMatch && method === 'POST') {
  return await handleProxyExecute(req, { actionId: executeMatch[1] });
}
```

Add TTL cleanup job AFTER the `initEncryption()` call and BEFORE `Bun.serve()`:
```typescript
// TTL cleanup: expire approved requests that haven't been executed
setInterval(() => {
  expireStaleApprovals().catch((err) => {
    console.error('Approval TTL cleanup error:', err);
  });
}, 5 * 60 * 1000); // Every 5 minutes
```

Also update the `handleProxyExecute` import — since it's exported from proxy.ts, update the existing import line to include it.
  </action>
  <verify>
TypeScript compilation: `cd /home/shashank/personal/gaiter-gaurd/backend && bunx tsc --noEmit src/server.ts` has no errors. Server starts: `cd /home/shashank/personal/gaiter-gaurd && timeout 5 bun run dev:backend 2>&1 || true` — should print "Server running on port" without crash (requires LLM env vars in .env). Verify route exists: `bun -e "import { handleApprovalStatus } from './src/routes/approval'; console.log(typeof handleApprovalStatus)"` prints "function". `bun -e "import { handleProxyExecute } from './src/routes/proxy'; console.log(typeof handleProxyExecute)"` prints "function".
  </verify>
  <done>GET /status/:actionId returns status-appropriate JSON responses (PENDING/APPROVED/DENIED/EXPIRED/EXECUTED). POST /proxy/execute/:actionId verifies ownership + APPROVED status, checks TTL, injects credentials fresh from vault, forwards stored request, caches response, returns result. server.ts wires both routes and starts 5-minute TTL cleanup interval. Full risk-to-execution flow is complete.</done>
</task>

</tasks>

<verification>
- POST /proxy with a risky request (e.g., DELETE method) returns 428 with action_id and status_url
- GET /status/{action_id} with valid Agent-Key returns { status: 'PENDING', ... }
- GET /status/{action_id} with wrong agent returns 404
- POST /proxy/execute/{action_id} with status !== APPROVED returns 409
- TTL cleanup interval is running (visible in server startup logs or setInterval registration)
- Auth headers are stripped from stored requestHeaders in approval_queue
- Server starts without errors with LLM env vars configured
</verification>

<success_criteria>
- Risky proxy requests return 428 with action_id, risk_score, risk_explanation, status_url
- Blocked requests stored in approval_queue with full context (URL, method, headers sans auth, body, intent, risk assessment)
- Agent can poll GET /status/{action_id} and receive PENDING, APPROVED, DENIED, EXPIRED, or EXECUTED
- Approved requests can be executed via POST /proxy/execute/{action_id} with fresh credential injection
- Executed responses cached in approval_queue for subsequent status polls
- TTL cleanup expires stale APPROVED entries every 5 minutes
- All 5 phase success criteria from ROADMAP.md are satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/05-risk-approval-flow/05-02-SUMMARY.md`
</output>
