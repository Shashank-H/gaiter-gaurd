---
phase: 04-gateway-proxy-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/db/schema.ts
  - backend/src/services/idempotency.service.ts
  - backend/src/services/proxy.service.ts
autonomous: true

must_haves:
  truths:
    - "Idempotency keys are stored in database with agent scope and TTL"
    - "Proxy service resolves service from target URL, retrieves and decrypts credentials"
    - "Credentials are injected into outbound request headers based on authType"
    - "Requests to target services use 30s timeout and return sanitized errors"
    - "SSRF is prevented by validating target URL against service baseUrl"
    - "Duplicate idempotency keys return cached response instead of re-executing"
  artifacts:
    - path: "backend/src/db/schema.ts"
      provides: "idempotencyKeys and proxyRequests table definitions"
      contains: "idempotencyKeys"
    - path: "backend/src/services/idempotency.service.ts"
      provides: "Idempotency check, complete, and fail operations"
      exports: ["checkIdempotency", "completeIdempotency", "failIdempotency"]
    - path: "backend/src/services/proxy.service.ts"
      provides: "Core proxy logic: URL validation, credential injection, request forwarding"
      exports: ["executeProxyRequest", "proxyRequestSchema"]
  key_links:
    - from: "backend/src/services/proxy.service.ts"
      to: "backend/src/services/encryption.service.ts"
      via: "decrypt() to retrieve credentials"
      pattern: "decrypt"
    - from: "backend/src/services/proxy.service.ts"
      to: "backend/src/services/idempotency.service.ts"
      via: "checkIdempotency before forwarding"
      pattern: "checkIdempotency"
    - from: "backend/src/services/proxy.service.ts"
      to: "backend/src/db/schema.ts"
      via: "services and credentials tables for lookup"
      pattern: "services.*credentials"
---

<objective>
Create the database schema for proxy tracking and build the core proxy service layer: idempotency management, URL validation, credential injection, and request forwarding.

Purpose: This is the foundation layer for the gateway proxy. The proxy service orchestrates the full request lifecycle: validate URL against registered service baseUrl (SSRF prevention), check idempotency, retrieve and decrypt credentials, inject them based on authType, forward via fetch with 30s timeout, cache response for idempotency, and return sanitized results.

Output: Two new service files (idempotency.service.ts, proxy.service.ts), updated schema.ts with two new tables, and a migration.
</objective>

<execution_context>
@/home/shashank/.claude/get-shit-done/workflows/execute-plan.md
@/home/shashank/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-gateway-proxy-core/04-RESEARCH.md

@backend/src/db/schema.ts
@backend/src/services/encryption.service.ts
@backend/src/services/service.service.ts
@backend/src/middleware/auth.ts
@backend/src/middleware/validation.ts
@backend/src/utils/responses.ts
@backend/drizzle.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add idempotency_keys and proxy_requests tables to schema, generate migration</name>
  <files>backend/src/db/schema.ts</files>
  <action>
Add two new tables to schema.ts following the existing pattern (integer PK with generatedAlwaysAsIdentity, timestamps, foreign keys with onDelete cascade):

**idempotency_keys table:**
- id: integer PK (generatedAlwaysAsIdentity)
- agentId: integer FK -> agents.id (cascade delete, notNull)
- key: varchar(255) notNull -- the idempotency key value
- requestHash: varchar(64) notNull -- SHA-256 hex of method+url+body for mismatch detection
- status: varchar(20) notNull -- 'processing', 'completed', 'failed'
- responseStatus: integer nullable -- HTTP status of cached response
- responseHeaders: text nullable -- JSON-serialized response headers (content-type etc)
- responseBody: text nullable -- cached response body
- createdAt: timestamp defaultNow notNull
- completedAt: timestamp nullable
- expiresAt: timestamp notNull -- 24 hour TTL from creation
- Indexes: uniqueIndex on (agentId, key), index on expiresAt

**proxy_requests table (audit log):**
- id: integer PK (generatedAlwaysAsIdentity)
- agentId: integer FK -> agents.id (cascade delete, notNull)
- serviceId: integer FK -> services.id (cascade delete, notNull)
- idempotencyKeyId: integer FK -> idempotencyKeys.id nullable
- method: varchar(10) notNull
- targetUrl: varchar(2048) notNull
- intent: varchar(500) notNull
- requestedAt: timestamp defaultNow notNull
- completedAt: timestamp nullable
- statusCode: integer nullable
- errorMessage: text nullable
- Indexes: index on agentId, index on serviceId, index on requestedAt

Export inferred types: IdempotencyKey, InsertIdempotencyKey, ProxyRequest, InsertProxyRequest.

After editing schema.ts, run: `cd backend && bun run db:generate` to create the migration, then `bun run db:migrate` to apply it.
  </action>
  <verify>
Run `cd backend && bun run db:generate` succeeds. Run `bun run db:migrate` succeeds. Verify tables exist by checking the generated migration SQL contains CREATE TABLE for both idempotency_keys and proxy_requests.
  </verify>
  <done>Both idempotency_keys and proxy_requests tables exist in the database with correct columns, indexes, and foreign key constraints. Types are exported from schema.ts.</done>
</task>

<task type="auto">
  <name>Task 2: Create idempotency service and proxy service</name>
  <files>backend/src/services/idempotency.service.ts, backend/src/services/proxy.service.ts</files>
  <action>
**idempotency.service.ts** -- Manages idempotency key lifecycle:

1. `checkIdempotency(agentId: number, key: string, requestHash: string)` -- Uses a database transaction (READ COMMITTED). Looks up existing record by (agentId, key). If found with status 'processing', return `{ status: 'processing' }` (caller returns 409). If found with status 'completed', return `{ status: 'completed', responseStatus, responseHeaders, responseBody }`. If found with status 'failed', delete the old record and create a new one in 'processing' state (retry). If not found, insert new record with status 'processing', expiresAt = now + 24 hours, requestHash. Return `{ status: 'new', idempotencyKeyId }`.

2. `completeIdempotency(id: number, responseStatus: number, responseHeaders: string, responseBody: string)` -- Update the record to status 'completed', set responseStatus/responseHeaders/responseBody, set completedAt.

3. `failIdempotency(id: number, errorMessage: string)` -- Update the record to status 'failed', set completedAt.

**proxy.service.ts** -- Core proxy orchestration:

1. **Zod schema** `proxyRequestSchema`: targetUrl (string, url), method (enum GET/POST/PUT/DELETE/PATCH/HEAD/OPTIONS), headers (optional record<string,string> default {}), body (optional nullable string), intent (string min 1 max 500), idempotencyKey (optional string min 1 max 255). Add refine: idempotencyKey required when method is POST or PATCH.

2. **SSRF prevention** `validateTargetUrl(targetUrl: string, serviceBaseUrl: string)`: Parse both URLs. Verify target hostname matches service baseUrl hostname. Verify target URL starts with service baseUrl path. Block private IP ranges (127.x, 10.x, 172.16-31.x, 192.168.x, 169.254.x, ::1, fc00:, fe80:). Only allow http/https protocols. Throw descriptive error on failure.

3. **Service resolution** `resolveService(targetUrl: string, agentId: number)`: Query services table joined with agent_services to find the service whose baseUrl matches the target URL's origin. Return the service record or throw 404 if no matching service found / agent doesn't have access.

4. **Credential injection** `injectCredentials(headers: Record<string,string>, serviceId: number, authType: string)`: Query credentials table for serviceId, decrypt each value using `decrypt()` from encryption.service.ts. Based on authType:
   - 'bearer': Set `Authorization: Bearer {token}`
   - 'api_key': Set `{header_name || 'X-API-Key'}: {api_key}` (use credential key name as header name, or default to X-API-Key if key is 'api_key')
   - 'basic': Set `Authorization: Basic {btoa(username:password)}`
   - 'oauth2': Set `Authorization: Bearer {access_token}`
   Return the modified headers. NEVER log credential values.

5. **Request forwarding** `forwardRequest(targetUrl: string, method: string, headers: Record<string,string>, body: string | null)`: Use fetch with AbortController (30s timeout). Disable redirects (`redirect: 'manual'`). Read response body as text. Enforce 10MB response size limit (check Content-Length header, abort if exceeded). Return { status, headers (serialized), body }.

6. **Main orchestrator** `executeProxyRequest(agentId: number, userId: number, data: validated proxy request)`: Orchestrate the full flow:
   a. resolveService (validates agent access + finds service)
   b. validateTargetUrl (SSRF check against service.baseUrl)
   c. If idempotencyKey provided: checkIdempotency. If completed, return cached. If processing, return 409.
   d. injectCredentials
   e. forwardRequest
   f. Log to proxy_requests table (fire-and-forget, like lastUsedAt pattern)
   g. If idempotencyKey: completeIdempotency (or failIdempotency on error)
   h. Return { status, headers, body } to caller

**Error sanitization**: Never expose internal error details. Map fetch errors to 502 Bad Gateway, timeouts to 504, and unknown errors to 500 with generic message. Include target hostname (safe) but not full URL or credentials.
  </action>
  <verify>
TypeScript compilation: `cd backend && bun build src/services/proxy.service.ts --no-bundle` succeeds without type errors. Same for idempotency.service.ts. Imports resolve correctly (encryption.service, schema, db).
  </verify>
  <done>
Both services compile, export all documented functions, and follow existing codebase patterns (Zod schemas, Drizzle queries, error classes). Proxy service orchestrates the full request lifecycle: resolve service, validate URL, check idempotency, inject credentials, forward request, log audit, cache response.
  </done>
</task>

</tasks>

<verification>
- `cd backend && bun build src/services/proxy.service.ts --no-bundle` compiles
- `cd backend && bun build src/services/idempotency.service.ts --no-bundle` compiles
- Schema has idempotency_keys and proxy_requests tables
- Migration applied successfully
- proxy.service.ts imports and uses decrypt() from encryption.service
- proxy.service.ts imports and uses checkIdempotency from idempotency.service
- proxyRequestSchema validates correct shape with idempotencyKey refinement
</verification>

<success_criteria>
1. Two new database tables (idempotency_keys, proxy_requests) exist with correct schema
2. Idempotency service handles check/complete/fail lifecycle with transaction isolation
3. Proxy service validates URLs against baseUrl, injects credentials by authType, forwards with timeout
4. All code compiles and follows existing codebase patterns
</success_criteria>

<output>
After completion, create `.planning/phases/04-gateway-proxy-core/04-01-SUMMARY.md`
</output>
