---
phase: 04-gateway-proxy-core
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - backend/src/routes/proxy.ts
  - backend/src/server.ts
autonomous: true

must_haves:
  truths:
    - "Agent can call POST /proxy with target URL, method, headers, body, intent, Agent-Key, and Idempotency-Key"
    - "Gateway injects real API credentials from the vault into the outbound request"
    - "Non-risky requests are forwarded to target service and return 200 with full response"
    - "Idempotency-Key prevents duplicate execution of the same request"
    - "Invalid Agent-Key returns 401"
    - "Agent without access to target service returns 403"
    - "Invalid request body returns 400 with validation errors"
  artifacts:
    - path: "backend/src/routes/proxy.ts"
      provides: "POST /proxy route handler"
      exports: ["handleProxy"]
    - path: "backend/src/server.ts"
      provides: "Server routing with /proxy endpoint wired in"
      contains: "handleProxy"
  key_links:
    - from: "backend/src/routes/proxy.ts"
      to: "backend/src/middleware/auth.ts"
      via: "requireAgentAuth for Agent-Key validation"
      pattern: "requireAgentAuth"
    - from: "backend/src/routes/proxy.ts"
      to: "backend/src/services/proxy.service.ts"
      via: "executeProxyRequest for full proxy lifecycle"
      pattern: "executeProxyRequest"
    - from: "backend/src/server.ts"
      to: "backend/src/routes/proxy.ts"
      via: "route registration for POST /proxy"
      pattern: "handleProxy"
---

<objective>
Create the POST /proxy route handler and wire it into the server. This is the agent-facing endpoint that accepts proxy requests, authenticates via Agent-Key, validates the request body, delegates to the proxy service, and returns the target service's response.

Purpose: This completes the gateway proxy feature by exposing it as an HTTP endpoint. Agents call POST /proxy with their Agent-Key header and a JSON body describing the target request. The handler authenticates, validates, proxies, and returns the result.

Output: New proxy route file, updated server.ts with /proxy wiring.
</objective>

<execution_context>
@/home/shashank/.claude/get-shit-done/workflows/execute-plan.md
@/home/shashank/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-gateway-proxy-core/04-RESEARCH.md
@.planning/phases/04-gateway-proxy-core/04-01-SUMMARY.md

@backend/src/server.ts
@backend/src/middleware/auth.ts
@backend/src/middleware/validation.ts
@backend/src/utils/responses.ts
@backend/src/routes/agents.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create POST /proxy route handler</name>
  <files>backend/src/routes/proxy.ts</files>
  <action>
Create `backend/src/routes/proxy.ts` following the pattern in routes/agents.ts and routes/services.ts:

**handleProxy(req: Request): Promise&lt;Response&gt;**

1. Authenticate: Call `requireAgentAuth(req)` to get `{ agentId, userId }`. If AuthError, return appropriate status.

2. Validate body: Call `validateBody(proxyRequestSchema)(req)` to parse and validate the JSON body. The proxyRequestSchema is imported from proxy.service.ts.

3. Extract Idempotency-Key header: Read `req.headers.get('Idempotency-Key')`. If the request body has an idempotencyKey field, use that. If Idempotency-Key header is also present, the header takes precedence (override body value). This allows agents to pass it either way.

4. Execute: Call `executeProxyRequest(agentId, userId, validatedData)` from proxy.service.ts.

5. Return response: The proxy service returns `{ status, headers, body }` from the target. Construct a Response with:
   - Status code from target response
   - Content-Type from target response headers (default to application/json)
   - Body as-is from target
   - Add `X-Proxy-Status: forwarded` header to indicate this went through the gateway
   - Add `X-Idempotency-Status: hit` or `X-Idempotency-Status: miss` header if idempotency key was used

6. Handle cached idempotency responses: If executeProxyRequest returns a cached result (from completed idempotency), return it with `X-Idempotency-Status: hit`.

7. Handle 409 Conflict: If idempotency check returns 'processing', return 409 with `{ error: "Request with this idempotency key is still processing" }`.

**Error handling** (try/catch wrapping the entire handler):
- AuthError: return errorResponse with error.statusCode (401 or 403)
- ValidationError: return errorResponse with 400 and validation issues
- NotFoundError: return errorResponse with 404 (service not found / no access)
- ProxyError (new, from proxy.service): return errorResponse with appropriate status (502, 504, etc.)
- Unknown: return errorResponse 500 "Internal server error"

Follow the same error handling pattern as routes/agents.ts.
  </action>
  <verify>
TypeScript compilation: `cd backend && bun build src/routes/proxy.ts --no-bundle` succeeds without errors. Verify it imports requireAgentAuth, validateBody, proxyRequestSchema, executeProxyRequest.
  </verify>
  <done>
POST /proxy handler authenticates agents via Agent-Key, validates request body with Zod, delegates to proxy service, returns target response with proxy metadata headers.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire proxy route into server and verify end-to-end</name>
  <files>backend/src/server.ts</files>
  <action>
Update `backend/src/server.ts`:

1. Add import: `import { handleProxy } from '@/routes/proxy';`

2. Add route matching in handleRequest function. After the existing agent routes block and before the "Check if path exists but with wrong method" section, add:

```
// Proxy endpoint (agent-facing)
if (pathname === '/proxy') {
  if (method === 'POST') return await handleProxy(req);
}
```

This follows the same parameterized routing pattern used for /services and /agents.

3. Do NOT add /proxy to the `routes` object (it uses the parameterized pattern like /services and /agents).

After wiring, verify the server starts:
- `cd backend && timeout 5 bun run dev || true` (just check it boots without crash)
  </action>
  <verify>
1. Server starts without errors: `cd backend && timeout 5 bun run start 2>&1 || true` shows "Server running on port" message.
2. Grep server.ts for handleProxy import and /proxy route.
3. `curl -s -X POST http://localhost:3000/proxy` returns 401 (missing Agent-Key), NOT 404 -- confirming the route is wired.
  </verify>
  <done>
POST /proxy endpoint is wired into the server. Unauthenticated requests return 401. The full proxy flow is accessible: Agent-Key auth -> validation -> service resolution -> credential injection -> forwarding -> response.
  </done>
</task>

</tasks>

<verification>
- Server starts without errors
- POST /proxy without Agent-Key returns 401 (not 404)
- POST /proxy with invalid JSON returns 400
- Route is properly imported and wired in server.ts
- All TypeScript files compile without errors
</verification>

<success_criteria>
1. POST /proxy endpoint exists and is reachable
2. Agent authentication via Agent-Key header works (401 without, 403 for wrong service)
3. Request validation via Zod schema rejects malformed requests with 400
4. Valid proxy requests are forwarded with injected credentials and return target response
5. Idempotency key header prevents duplicate execution
</success_criteria>

<output>
After completion, create `.planning/phases/04-gateway-proxy-core/04-02-SUMMARY.md`
</output>
