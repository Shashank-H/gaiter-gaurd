---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - bunfig.toml
  - .env
  - .env.example
  - .gitignore
  - drizzle.config.ts
  - src/server.ts
  - src/config/db.ts
  - src/config/env.ts
  - src/db/schema.ts
  - src/db/migrations/
  - src/utils/responses.ts
  - src/routes/health.ts
  - scripts/migrate.ts
autonomous: true

must_haves:
  truths:
    - "Bun.js server starts and listens on configured port"
    - "GET /health returns 200 OK"
    - "GET /ready returns 200 with database connection status"
    - "GET /ready returns 503 when database is unreachable"
    - "PostgreSQL database has users and refresh_tokens tables after migration"
    - "API error responses return structured JSON with error and statusCode fields"
  artifacts:
    - path: "src/server.ts"
      provides: "Bun.serve() entry point with route registration"
      min_lines: 20
    - path: "src/config/db.ts"
      provides: "Drizzle ORM database connection via postgres.js"
      exports: ["db"]
    - path: "src/config/env.ts"
      provides: "Validated environment variable access"
      exports: ["env"]
    - path: "src/db/schema.ts"
      provides: "Drizzle table definitions for users and refresh_tokens"
      contains: "pgTable"
    - path: "src/utils/responses.ts"
      provides: "JSON response and error response helpers"
      exports: ["jsonResponse", "errorResponse"]
    - path: "drizzle.config.ts"
      provides: "Drizzle Kit configuration for migrations"
      contains: "defineConfig"
    - path: "scripts/migrate.ts"
      provides: "Standalone migration runner script"
      min_lines: 10
  key_links:
    - from: "src/server.ts"
      to: "src/routes/health.ts"
      via: "route registration"
      pattern: "health"
    - from: "src/routes/health.ts"
      to: "src/config/db.ts"
      via: "database ping in /ready"
      pattern: "db.*execute|sql"
    - from: "src/config/db.ts"
      to: "src/db/schema.ts"
      via: "schema import for typed queries"
      pattern: "import.*schema"
---

<objective>
Scaffold the GaiterGuard project with Bun.js server, PostgreSQL database connection via Drizzle ORM, and health check endpoints.

Purpose: Establish the runnable foundation — a server that starts, connects to the database, and responds to requests with structured JSON.
Output: Working Bun.js HTTP server with health/ready endpoints and migrated PostgreSQL database with users and refresh_tokens tables.
</objective>

<execution_context>
@/home/shashank/.claude/get-shit-done/workflows/execute-plan.md
@/home/shashank/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Project scaffolding, database schema, and migration system</name>
  <files>
    package.json
    tsconfig.json
    bunfig.toml
    .env
    .env.example
    .gitignore
    drizzle.config.ts
    src/config/env.ts
    src/config/db.ts
    src/db/schema.ts
    scripts/migrate.ts
  </files>
  <action>
    1. Initialize Bun project: `bun init -y` in the project root. Update package.json with name "gaiter-guard", add scripts: "dev": "bun --watch src/server.ts", "start": "bun src/server.ts", "db:generate": "bun drizzle-kit generate", "db:migrate": "bun run scripts/migrate.ts".

    2. Install dependencies: `bun add drizzle-orm postgres jose` and `bun add -D drizzle-kit @types/bun`.

    3. Create tsconfig.json with strict mode, ES2022 target, module "ESNext", moduleResolution "bundler", paths alias "@/*" -> "./src/*".

    4. Create .env with DATABASE_URL=postgres://pglocal:pglocal-pass@localhost:5432/gaiterguard, PORT=3000, JWT_SECRET=dev-secret-change-in-production, JWT_ACCESS_EXPIRY=15m, JWT_REFRESH_EXPIRY=7d. Create .env.example with same keys but placeholder values.

    5. Update .gitignore to include node_modules, .env, dist, *.log, src/db/migrations/meta/.

    6. Create src/config/env.ts — centralized env validation. Export `env` object with DATABASE_URL, PORT (parsed to number, default 3000), JWT_SECRET, JWT_ACCESS_EXPIRY, JWT_REFRESH_EXPIRY. Throw on missing required vars (DATABASE_URL, JWT_SECRET) at import time.

    7. Create src/config/db.ts — initialize postgres.js client with `postgres(env.DATABASE_URL, { max: 10 })`, export Drizzle instance: `export const db = drizzle({ client: queryClient })`. Also export `queryClient` for use in migration script.

    8. Create src/db/schema.ts with two tables using Drizzle's pgTable:
       - `users`: id (integer, primaryKey, generatedAlwaysAsIdentity), email (varchar 255, notNull, unique), passwordHash (varchar 255, notNull), createdAt (timestamp, defaultNow, notNull), updatedAt (timestamp, defaultNow, notNull).
       - `refreshTokens`: id (integer, primaryKey, generatedAlwaysAsIdentity), userId (integer, references users.id, notNull), tokenHash (varchar 255, notNull), expiresAt (timestamp, notNull), createdAt (timestamp, defaultNow, notNull). Add index on userId column per research pitfall #5.
       Export both tables and inferred types (InferSelectModel, InferInsertModel).

    9. Create drizzle.config.ts using defineConfig: dialect "postgresql", schema "./src/db/schema.ts", out "./src/db/migrations", dbCredentials url from DATABASE_URL env var.

    10. Create scripts/migrate.ts — standalone migration runner. Create a dedicated postgres client with `{ max: 1 }`, run `migrate(db, { migrationsFolder: './src/db/migrations' })`, close connection, log success. Exit with code 1 on error.

    11. Ensure the PostgreSQL database exists: run `createdb gaiterguard` via psql or handle it gracefully. Then generate and run migrations: `bun run db:generate && bun run db:migrate`.
  </action>
  <verify>
    - `bun run db:migrate` completes without errors
    - `psql postgres://pglocal:pglocal-pass@localhost:5432/gaiterguard -c "SELECT * FROM users LIMIT 0"` returns empty result (table exists)
    - `psql postgres://pglocal:pglocal-pass@localhost:5432/gaiterguard -c "SELECT * FROM refresh_tokens LIMIT 0"` returns empty result (table exists)
    - `bun run src/config/env.ts` does not throw (env validation passes)
  </verify>
  <done>
    Package.json has all dependencies and scripts. Database has users and refresh_tokens tables created via Drizzle migrations. Environment config validates required vars at import time.
  </done>
</task>

<task type="auto">
  <name>Task 2: Bun HTTP server with health endpoints and response utilities</name>
  <files>
    src/server.ts
    src/utils/responses.ts
    src/routes/health.ts
  </files>
  <action>
    1. Create src/utils/responses.ts with two helpers:
       - `jsonResponse<T>(data: T, status = 200): Response` — returns Response.json with proper Content-Type header
       - `errorResponse(message: string, statusCode = 500): Response` — returns Response.json with `{ error: message, statusCode }` shape
       These are used everywhere for consistent API responses.

    2. Create src/routes/health.ts exporting two route handlers:
       - `healthHandler`: returns `jsonResponse({ status: "ok" })` — fast liveness check, no DB call
       - `readyHandler`: async, runs `db.execute(sql\`SELECT 1\`)` (import sql from drizzle-orm), returns `jsonResponse({ status: "ready", database: "connected" })` on success, returns `errorResponse("Database connection failed", 503)` on catch

    3. Create src/server.ts as the main entry point:
       - Import env from config/env (triggers validation)
       - Import route handlers
       - Use `Bun.serve()` with a `fetch` handler that does URL pathname matching (use `new URL(req.url).pathname`). Register routes:
         - GET /health -> healthHandler
         - GET /ready -> readyHandler
         - Default: errorResponse("Not found", 404)
       - Add method checking — only GET for health routes, return errorResponse("Method not allowed", 405) for wrong methods
       - Add global error handler via the `error` callback on Bun.serve: return errorResponse with the error message
       - Log "Server running on port {PORT}" on startup

    Note: Do NOT use Bun's `routes` object syntax yet — use a fetch handler with pathname matching. The `routes` object API may have changed between Bun versions and a simple fetch handler is more portable. Structure the fetch handler to be extensible (we will add auth routes in Plan 02).
  </action>
  <verify>
    - `bun run dev` starts the server (verify "Server running on port 3000" in output)
    - `curl http://localhost:3000/health` returns `{"status":"ok"}` with 200
    - `curl http://localhost:3000/ready` returns `{"status":"ready","database":"connected"}` with 200
    - `curl http://localhost:3000/nonexistent` returns `{"error":"Not found","statusCode":404}` with 404
    - `curl -X POST http://localhost:3000/health` returns 405 Method Not Allowed
  </verify>
  <done>
    Server starts on configured port, /health returns 200, /ready pings database and returns 200 when connected or 503 when not, unknown routes return 404, wrong methods return 405, all responses are structured JSON.
  </done>
</task>

</tasks>

<verification>
1. `bun run dev` starts without errors
2. Health endpoints respond correctly (200 for /health, 200 for /ready with DB connected)
3. Database tables exist and match schema (users, refresh_tokens)
4. Error responses follow `{ error, statusCode }` format
5. All environment variables validated at startup
</verification>

<success_criteria>
- Bun.js server runs and responds to health check requests
- PostgreSQL database is provisioned with users and refresh_tokens tables via Drizzle migrations
- GET /health returns 200 with { status: "ok" }
- GET /ready returns 200 with database connection confirmation or 503 on failure
- All API responses use consistent JSON structure
- Migration system functional (generate + migrate scripts work)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
