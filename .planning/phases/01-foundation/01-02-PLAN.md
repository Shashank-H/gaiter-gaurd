---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/services/auth.service.ts
  - src/routes/auth.ts
  - src/middleware/auth.ts
  - src/server.ts
  - src/utils/jwt.ts
autonomous: true

must_haves:
  truths:
    - "User can register with email and password via POST /auth/register"
    - "User can login with valid credentials via POST /auth/login"
    - "Login returns access token and refresh token"
    - "Invalid credentials return 401 error"
    - "Duplicate email registration returns 409 error"
    - "Protected endpoint rejects requests without valid access token"
    - "User can refresh access token via POST /auth/refresh"
    - "Refresh token is rotated on each use (old token invalidated)"
  artifacts:
    - path: "src/utils/jwt.ts"
      provides: "JWT creation and verification using jose library"
      exports: ["signAccessToken", "signRefreshToken", "verifyAccessToken"]
    - path: "src/services/auth.service.ts"
      provides: "Registration, login, and token refresh business logic"
      exports: ["registerUser", "loginUser", "refreshAccessToken"]
    - path: "src/routes/auth.ts"
      provides: "Auth route handlers for register, login, refresh"
      exports: ["handleRegister", "handleLogin", "handleRefresh"]
    - path: "src/middleware/auth.ts"
      provides: "JWT validation middleware for protected routes"
      exports: ["requireAuth"]
  key_links:
    - from: "src/routes/auth.ts"
      to: "src/services/auth.service.ts"
      via: "function calls for business logic"
      pattern: "registerUser|loginUser|refreshAccessToken"
    - from: "src/services/auth.service.ts"
      to: "src/db/schema.ts"
      via: "Drizzle queries on users and refreshTokens tables"
      pattern: "db\\.(select|insert|delete).*users|refreshTokens"
    - from: "src/services/auth.service.ts"
      to: "src/utils/jwt.ts"
      via: "token generation"
      pattern: "signAccessToken|signRefreshToken"
    - from: "src/middleware/auth.ts"
      to: "src/utils/jwt.ts"
      via: "token verification"
      pattern: "verifyAccessToken"
    - from: "src/server.ts"
      to: "src/routes/auth.ts"
      via: "route registration in fetch handler"
      pattern: "/auth/"
---

<objective>
Implement user authentication with email/password registration, login, JWT access tokens, and refresh token rotation.

Purpose: Dashboard users need to authenticate to manage services and approve agent actions. This establishes the auth framework used by all subsequent phases.
Output: Working auth endpoints (register, login, refresh) with JWT-protected route middleware.
</objective>

<execution_context>
@/home/shashank/.claude/get-shit-done/workflows/execute-plan.md
@/home/shashank/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: JWT utilities and auth service with registration, login, and token refresh</name>
  <files>
    src/utils/jwt.ts
    src/services/auth.service.ts
  </files>
  <action>
    1. Create src/utils/jwt.ts using the `jose` library (per research recommendation):
       - Import `SignJWT`, `jwtVerify` from "jose"
       - Create secret key: `new TextEncoder().encode(env.JWT_SECRET)`
       - `signAccessToken(userId: number)`: creates JWT with `{ sub: String(userId) }`, algorithm HS256, issued now, expires in 15 minutes. Returns signed token string.
       - `signRefreshToken(userId: number)`: creates JWT with `{ sub: String(userId), type: "refresh" }`, algorithm HS256, expires in 7 days. Returns signed token string.
       - `verifyAccessToken(token: string)`: verifies JWT with the secret, returns `{ userId: number }` (parsed from sub claim). Throws on invalid/expired tokens.
       - Parse expiry durations from env.JWT_ACCESS_EXPIRY and env.JWT_REFRESH_EXPIRY strings.

    2. Create src/services/auth.service.ts with three functions:

       `registerUser(email: string, password: string)`:
       - Validate email format (basic regex) and password length (min 8 chars). Throw descriptive errors on failure.
       - Check if email exists in users table. If yes, throw error "User with this email already exists".
       - Hash password with `Bun.password.hash(password, { algorithm: "argon2id", memoryCost: 65536, timeCost: 2 })`.
       - Insert into users table, return `{ id, email }` (never return passwordHash).

       `loginUser(email: string, password: string)`:
       - Find user by email. If not found, throw "Invalid credentials" (don't reveal whether email exists).
       - Verify password with `Bun.password.verify(password, user.passwordHash)`. If invalid, throw "Invalid credentials".
       - Generate access token and refresh token using jwt utils.
       - Hash the refresh token with `Bun.password.hash(refreshToken)` and store in refresh_tokens table with userId and expiresAt (7 days from now).
       - Return `{ accessToken, refreshToken, user: { id, email } }`.

       `refreshAccessToken(refreshToken: string)`:
       - Verify the refresh token JWT signature first (confirms it's a valid, non-expired token we signed).
       - Extract userId from the JWT payload.
       - Fetch all non-expired refresh tokens for this userId from the database.
       - Iterate and find the one where `Bun.password.verify(refreshToken, storedHash)` returns true.
       - If no match found, throw "Invalid refresh token".
       - Delete the matched token from the database (single-use rotation).
       - Generate new access token and new refresh token.
       - Store new refresh token hash in database.
       - Return `{ accessToken, refreshToken }`.

    Note: Use `eq` and `gt` from drizzle-orm for query conditions. Import `db` from config/db and tables from db/schema.
  </action>
  <verify>
    - `bun run src/utils/jwt.ts` does not throw (module loads)
    - `bun run src/services/auth.service.ts` does not throw (module loads)
    - Types compile: `bun build src/services/auth.service.ts --no-bundle` succeeds
  </verify>
  <done>
    JWT utility creates and verifies HS256 tokens with jose. Auth service handles registration (with Argon2id hashing), login (with credential verification + token pair generation), and refresh (with token rotation). No raw passwords or tokens stored — only hashes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Auth routes, auth middleware, and server integration</name>
  <files>
    src/routes/auth.ts
    src/middleware/auth.ts
    src/server.ts
  </files>
  <action>
    1. Create src/middleware/auth.ts:
       - Export `requireAuth(req: Request): Promise<{ userId: number }>` function.
       - Extract Bearer token from Authorization header. If missing, throw error with status 401 "Missing authorization header".
       - Call `verifyAccessToken(token)` from jwt utils. If verification fails, throw error with status 401 "Invalid or expired token".
       - Return `{ userId }` on success.
       - Define a simple custom error class `AuthError` with statusCode property for route handlers to catch and return appropriate HTTP status.

    2. Create src/routes/auth.ts with three handler functions:

       `handleRegister(req: Request): Promise<Response>`:
       - Parse JSON body, extract email and password.
       - Call `registerUser(email, password)`.
       - On success: return `jsonResponse({ message: "User registered", user }, 201)`.
       - On "already exists" error: return `errorResponse("User with this email already exists", 409)`.
       - On validation error: return `errorResponse(message, 400)`.

       `handleLogin(req: Request): Promise<Response>`:
       - Parse JSON body, extract email and password.
       - Call `loginUser(email, password)`.
       - On success: return `jsonResponse({ accessToken, refreshToken, user })`.
       - On "Invalid credentials": return `errorResponse("Invalid credentials", 401)`.

       `handleRefresh(req: Request): Promise<Response>`:
       - Parse JSON body, extract refreshToken.
       - Call `refreshAccessToken(refreshToken)`.
       - On success: return `jsonResponse({ accessToken, refreshToken })`.
       - On error: return `errorResponse("Invalid refresh token", 401)`.

       `handleMe(req: Request): Promise<Response>`:
       - Call `requireAuth(req)` to get userId.
       - Query user by id from database (select id, email, createdAt only — never passwordHash).
       - Return `jsonResponse({ user })`.
       - On AuthError: return `errorResponse(error.message, error.statusCode)`.

    3. Update src/server.ts fetch handler to add auth routes:
       - POST /auth/register -> handleRegister
       - POST /auth/login -> handleLogin
       - POST /auth/refresh -> handleRefresh
       - GET /auth/me -> handleMe (protected, uses requireAuth)
       - Ensure existing health routes still work.
       - Add proper method checking for auth routes (POST for register/login/refresh, GET for me).
       - Wrap all route handlers in try/catch to return `errorResponse("Internal server error", 500)` on unexpected errors.
  </action>
  <verify>
    Start the server with `bun run dev`, then test the full flow:

    1. Register: `curl -s -X POST http://localhost:3000/auth/register -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"password123"}' | jq .` — should return 201 with user object
    2. Duplicate register: same curl again — should return 409
    3. Login: `curl -s -X POST http://localhost:3000/auth/login -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"password123"}' | jq .` — should return 200 with accessToken, refreshToken, user
    4. Bad login: `curl -s -X POST http://localhost:3000/auth/login -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"wrong"}' | jq .` — should return 401
    5. Protected route: `curl -s http://localhost:3000/auth/me -H "Authorization: Bearer {accessToken}" | jq .` — should return user data
    6. No token: `curl -s http://localhost:3000/auth/me | jq .` — should return 401
    7. Refresh: `curl -s -X POST http://localhost:3000/auth/refresh -H "Content-Type: application/json" -d '{"refreshToken":"{refreshToken}"}' | jq .` — should return new token pair
    8. Old refresh reuse: same refresh curl again — should return 401 (token rotated)
    9. Health still works: `curl http://localhost:3000/health` — should return 200
  </verify>
  <done>
    All auth endpoints functional: register returns 201 (or 409 on duplicate), login returns tokens (or 401 on bad credentials), refresh rotates tokens (or 401 on invalid/reused token), /auth/me returns user data when authenticated (or 401 without valid token). Health endpoints unaffected. All responses use structured JSON format.
  </done>
</task>

</tasks>

<verification>
1. Full auth flow works: register -> login -> access protected route -> refresh -> access again
2. Error cases handled: duplicate email (409), bad password (401), missing token (401), expired token (401), reused refresh token (401)
3. Passwords stored as Argon2id hashes, never exposed in responses
4. Refresh tokens rotated on each use (old token invalidated in database)
5. Health endpoints still functional alongside auth routes
6. All responses follow `{ error, statusCode }` or `{ data }` JSON structure
</verification>

<success_criteria>
- User can register with email/password and receive 201
- User can login and receive JWT access token + refresh token
- Protected routes reject unauthenticated requests with 401
- Refresh token rotation works (new pair issued, old token invalidated)
- Invalid credentials return 401 without leaking whether email exists
- All four Phase 1 success criteria from ROADMAP.md are met
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
