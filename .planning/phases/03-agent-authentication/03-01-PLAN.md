---
phase: 03-agent-authentication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/db/schema.ts
  - backend/src/utils/apikey.ts
  - backend/src/services/agent.service.ts
autonomous: true

must_haves:
  truths:
    - "System generates a unique Agent-Key when a new agent is created"
    - "Agent-Key is hashed before storage, never stored plaintext"
    - "Agent creation returns the full key exactly once"
    - "Agents are scoped to specific services via join table"
  artifacts:
    - path: "backend/src/db/schema.ts"
      provides: "agents and agent_services tables"
      contains: "agents"
    - path: "backend/src/utils/apikey.ts"
      provides: "API key generation, hashing, validation utilities"
      exports: ["generateApiKey", "hashApiKey", "validateApiKey"]
    - path: "backend/src/services/agent.service.ts"
      provides: "Agent CRUD operations with encrypted key storage"
      exports: ["createAgent", "getAgentsByUser", "getAgentById", "updateAgent", "deleteAgent", "updateAgentServices"]
  key_links:
    - from: "backend/src/services/agent.service.ts"
      to: "backend/src/utils/apikey.ts"
      via: "generateApiKey and hashApiKey imports"
      pattern: "import.*from.*apikey"
    - from: "backend/src/services/agent.service.ts"
      to: "backend/src/db/schema.ts"
      via: "agents and agentServices table references"
      pattern: "agents|agentServices"
---

<objective>
Add agent identity schema, API key utilities, and agent service layer.

Purpose: Establish the data model and business logic for agent authentication - the foundation that routes and middleware will build on.
Output: Database tables for agents and agent-service scoping, cryptographic API key utilities, and a complete agent service with CRUD operations.
</objective>

<execution_context>
@/home/shashank/.claude/get-shit-done/workflows/execute-plan.md
@/home/shashank/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-agent-authentication/03-RESEARCH.md
@backend/src/db/schema.ts
@backend/src/services/service.service.ts
@backend/src/utils/responses.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add agents and agent_services schema + API key utilities</name>
  <files>backend/src/db/schema.ts, backend/src/utils/apikey.ts</files>
  <action>
1. In `backend/src/db/schema.ts`, add `boolean` to the drizzle-orm/pg-core import, then add two new tables:

**agents table:**
- id: integer, primaryKey, generatedAlwaysAsIdentity
- userId: integer, references users.id, notNull
- name: varchar(255), notNull (human-readable agent name)
- keyHash: varchar(64), notNull, unique (SHA-256 hex digest)
- keyPrefix: varchar(16), notNull (first 12 chars of key for display, e.g. "agt_a3f2b1c8")
- isActive: boolean, default(true), notNull (soft revocation flag)
- lastUsedAt: timestamp, nullable (track last request)
- createdAt: timestamp, defaultNow, notNull
- updatedAt: timestamp, defaultNow, notNull
- Indexes: userIdIdx on userId, keyHashIdx as uniqueIndex on keyHash

**agent_services table (many-to-many join):**
- id: integer, primaryKey, generatedAlwaysAsIdentity
- agentId: integer, references agents.id with onDelete cascade, notNull
- serviceId: integer, references services.id with onDelete cascade, notNull
- createdAt: timestamp, defaultNow, notNull
- Indexes: agentIdIdx on agentId, serviceIdIdx on serviceId, uniquePair as uniqueIndex on (agentId, serviceId)

Export types: Agent, InsertAgent, AgentService, InsertAgentService

2. Create `backend/src/utils/apikey.ts` with three functions:

- `generateApiKey()`: Uses `crypto.randomBytes(32).toString('hex')` with `agt_` prefix. Returns string like `agt_{64_hex_chars}`.
- `hashApiKey(apiKey: string)`: Returns `createHash('sha256').update(apiKey).digest('hex')`.
- `validateApiKey(providedKey: string, storedHash: string)`: Hashes provided key, converts both to Buffer, uses `timingSafeEqual` for constant-time comparison. Returns false on any error (length mismatch etc).

Import from `node:crypto` (randomBytes, createHash, timingSafeEqual).
  </action>
  <verify>Run `bun run --bun backend/src/db/schema.ts` to check for TypeScript compilation errors. Run `bunx drizzle-kit push` from backend/ to apply schema changes to the database (or verify with `bunx drizzle-kit generate` that migration SQL looks correct).</verify>
  <done>agents and agent_services tables defined in schema.ts with proper indexes, types exported. apikey.ts exports generateApiKey, hashApiKey, validateApiKey using node:crypto.</done>
</task>

<task type="auto">
  <name>Task 2: Create agent service layer with CRUD operations</name>
  <files>backend/src/services/agent.service.ts</files>
  <action>
Create `backend/src/services/agent.service.ts` following the pattern in service.service.ts. Use Drizzle ORM with the db instance from `@/config/db`.

**Zod schemas (define at top):**
- `createAgentSchema`: { name: string (3-100 chars), serviceIds: number[] (min 1 item, each positive integer) }
- `updateAgentSchema`: { name?: string (3-100 chars), isActive?: boolean }
- `updateAgentServicesSchema`: { serviceIds: number[] (min 1 item, each positive integer) }

**Functions:**

1. `createAgent(userId: number, data: { name, serviceIds })`:
   - Generate API key via generateApiKey()
   - Hash key via hashApiKey()
   - Extract keyPrefix as first 12 chars of the full key
   - Verify all serviceIds belong to the user (query services table WHERE userId AND id IN serviceIds)
   - If any service not found/not owned, throw NotFoundError
   - Use db.transaction: insert into agents, then insert into agent_services for each serviceId
   - Return { agent: { id, name, keyPrefix, isActive, createdAt }, apiKey } -- full key returned ONLY here

2. `getAgentsByUser(userId: number)`:
   - Select all agents WHERE userId, ordered by createdAt desc
   - For each agent, query agent_services joined with services to get service names/ids
   - Return array of { id, name, keyPrefix, isActive, lastUsedAt, createdAt, services: [{ id, name }] }

3. `getAgentById(agentId: number, userId: number)`:
   - Select agent WHERE id AND userId
   - If not found, throw NotFoundError
   - Include services via agent_services join
   - Return { id, name, keyPrefix, isActive, lastUsedAt, createdAt, updatedAt, services: [{ id, name }] }

4. `updateAgent(agentId: number, userId: number, data: { name?, isActive? })`:
   - Verify ownership (userId match)
   - Update fields + set updatedAt to new Date()
   - Return updated agent

5. `deleteAgent(agentId: number, userId: number)`:
   - Verify ownership
   - Delete agent (cascade will remove agent_services entries)
   - Return void

6. `updateAgentServices(agentId: number, userId: number, data: { serviceIds })`:
   - Verify agent ownership
   - Verify all serviceIds belong to user
   - Use transaction: delete all existing agent_services for agent, insert new ones
   - Return updated service list

Export all functions and schemas. Create NotFoundError class if not importing from service.service (or import it).
  </action>
  <verify>Run `bun run --bun backend/src/services/agent.service.ts` to verify TypeScript compilation. Check that all exported functions and schemas are accessible.</verify>
  <done>agent.service.ts exports createAgent (returns full API key once), getAgentsByUser, getAgentById, updateAgent, deleteAgent, updateAgentServices, plus Zod validation schemas. All operations verify user ownership. createAgent uses transactions for atomic agent+scope creation.</done>
</task>

</tasks>

<verification>
- Schema file compiles with both new tables and all existing tables intact
- API key utility generates keys with agt_ prefix and 64 hex chars
- API key hashing produces consistent SHA-256 hex output
- Agent service functions handle ownership verification
- Database migration applies cleanly (agents and agent_services tables created)
</verification>

<success_criteria>
- agents and agent_services tables exist in database with correct columns, indexes, and foreign keys
- generateApiKey() produces unique, prefixed keys
- hashApiKey() produces deterministic SHA-256 hashes
- validateApiKey() uses constant-time comparison
- createAgent() returns full key exactly once, stores only hash
- All CRUD operations enforce user ownership
</success_criteria>

<output>
After completion, create `.planning/phases/03-agent-authentication/03-01-SUMMARY.md`
</output>
