---
phase: 06-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/services/approval.service.ts
  - backend/src/routes/dashboard.ts
  - backend/src/server.ts
  - frontend/package.json
  - frontend/tsconfig.json
  - frontend/app.config.ts
  - frontend/src/router.tsx
  - frontend/src/client.tsx
  - frontend/src/ssr.tsx
  - frontend/src/routes/__root.tsx
  - frontend/src/routes/index.tsx
  - frontend/src/routes/login.tsx
  - frontend/src/routes/_auth.tsx
  - frontend/src/api/endpoints.ts
  - frontend/src/lib/api-client.ts
  - frontend/src/styles/overrides.css
  - frontend/src/components/primitives/Button.tsx
  - frontend/src/components/primitives/Badge.tsx
  - frontend/src/components/primitives/Card.tsx
  - frontend/src/components/primitives/Spinner.tsx
  - frontend/src/components/primitives/Skeleton.tsx
  - frontend/src/components/primitives/Modal.tsx
autonomous: true
requirements:
  - DASH-01
  - DASH-02

must_haves:
  truths:
    - "Backend returns list of PENDING approval entries for the authenticated user"
    - "Backend transitions PENDING to APPROVED or DENIED on dashboard request"
    - "Frontend app starts with bun run dev and renders a login page"
    - "Authenticated routes redirect to /login when no token present"
    - "oat.ink dark theme renders on all pages with Vercel-style overrides"
  artifacts:
    - path: "backend/src/routes/dashboard.ts"
      provides: "Dashboard-facing approval endpoints"
      exports: ["handleListPendingApprovals", "handleApproveAction", "handleDenyAction"]
    - path: "backend/src/services/approval.service.ts"
      provides: "listPendingForUser query"
      contains: "listPendingForUser"
    - path: "frontend/src/api/endpoints.ts"
      provides: "Centralized backend API URLs"
      contains: "BACKEND_BASE"
    - path: "frontend/src/routes/__root.tsx"
      provides: "Root layout with oat.ink and QueryClientProvider"
      contains: "data-theme"
    - path: "frontend/src/routes/_auth.tsx"
      provides: "Auth guard layout route"
      contains: "beforeLoad"
  key_links:
    - from: "backend/src/routes/dashboard.ts"
      to: "backend/src/services/approval.service.ts"
      via: "listPendingForUser, transitionStatus"
      pattern: "listPendingForUser|transitionStatus"
    - from: "backend/src/server.ts"
      to: "backend/src/routes/dashboard.ts"
      via: "route registration"
      pattern: "handleListPendingApprovals|handleApproveAction|handleDenyAction"
    - from: "frontend/src/api/endpoints.ts"
      to: "backend API"
      via: "fetch calls to BACKEND_BASE"
      pattern: "BACKEND_BASE"
---

<objective>
Backend approval management endpoints + frontend scaffolding with TanStack Start, oat.ink dark theme, auth flow, centralized API client, and reusable component primitives.

Purpose: The backend currently has NO dashboard-facing approval endpoints (only agent-facing GET /status). The frontend directory does not exist. This plan creates the backend endpoints needed by DASH-01 and scaffolds the entire frontend foundation needed by both DASH-01 and DASH-02.

Output: Three new backend endpoints (GET /approvals/pending, PATCH /approvals/:actionId/approve, PATCH /approvals/:actionId/deny), a running TanStack Start app with login page, auth guard, centralized API client, oat.ink dark theme, and 6 reusable UI primitives.
</objective>

<execution_context>
@/home/shashank/.claude/get-shit-done/workflows/execute-plan.md
@/home/shashank/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-dashboard/06-RESEARCH.md
@backend/src/services/approval.service.ts
@backend/src/routes/approval.ts
@backend/src/middleware/auth.ts
@backend/src/server.ts
@backend/src/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend dashboard approval endpoints</name>
  <files>
    backend/src/services/approval.service.ts
    backend/src/routes/dashboard.ts
    backend/src/server.ts
  </files>
  <action>
Add a new function `listPendingForUser(userId: number)` to `backend/src/services/approval.service.ts`. This function joins `approvalQueue` with `agents` table to find all PENDING entries where `agents.userId = userId`. Returns an array of approval queue rows with agent name included. Use Drizzle `innerJoin` on `approvalQueue.agentId = agents.id`, filtered by `approvalQueue.status = 'PENDING'` AND `agents.userId = userId`. Order by `createdAt DESC`.

Create `backend/src/routes/dashboard.ts` with three handlers, all using `requireAuth` (JWT, not Agent-Key):

1. `handleListPendingApprovals(req: Request)` — calls `listPendingForUser(userId)`, returns `{ approvals: [...] }` with each entry containing: `action_id`, `agent_name`, `service_id`, `method`, `target_url`, `intent`, `risk_score`, `risk_explanation`, `request_headers` (parsed JSON), `request_body`, `created_at`.

2. `handleApproveAction(req: Request, params: { actionId: string })` — ownership check: fetch entry via `getApprovalQueueEntry(actionId)`, then join to verify `agents.userId = userId` (return 404 if not found or wrong user). Call `transitionStatus(actionId, 'PENDING', 'APPROVED', { resolvedAt: new Date(), approvalExpiresAt: new Date(Date.now() + env.APPROVAL_EXECUTE_TTL_HOURS * 3600000) })`. Return 200 `{ status: 'APPROVED', action_id }` on success, 409 if transition fails (already resolved).

3. `handleDenyAction(req: Request, params: { actionId: string })` — same ownership check pattern. Call `transitionStatus(actionId, 'PENDING', 'DENIED', { resolvedAt: new Date() })`. Return 200 `{ status: 'DENIED', action_id }` on success, 409 if already resolved.

Wire into `backend/src/server.ts`:
- Import the three handlers from `@/routes/dashboard`
- Add route: `GET /approvals/pending` -> `handleListPendingApprovals`
- Add parameterized route: `/approvals/([0-9a-f-]{36})/approve` for PATCH -> `handleApproveAction`
- Add parameterized route: `/approvals/([0-9a-f-]{36})/deny` for PATCH -> `handleDenyAction`

Also add CORS support to the server: for any request, if `Origin` header is present and matches `http://localhost:*`, add `Access-Control-Allow-Origin`, `Access-Control-Allow-Methods` (GET, POST, PUT, PATCH, DELETE, OPTIONS), `Access-Control-Allow-Headers` (Content-Type, Authorization), and `Access-Control-Allow-Credentials: true` to the response. Handle OPTIONS preflight by returning 204 with these headers immediately. Wrap the existing `handleRequest` function to add CORS headers to every response.
  </action>
  <verify>
Run `bunx tsc --noEmit` from backend/ to check TypeScript compilation. Verify the three new exports exist: `grep -r "handleListPendingApprovals\|handleApproveAction\|handleDenyAction" backend/src/`. Verify CORS handler exists: `grep "Access-Control" backend/src/server.ts`.
  </verify>
  <done>
Three dashboard-facing approval endpoints registered in server.ts. listPendingForUser joins approvalQueue with agents by userId. Approve sets approvalExpiresAt per TTL env var. Deny sets resolvedAt. CORS headers added for frontend dev server communication. TypeScript compiles without new errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Frontend scaffolding with TanStack Start, auth, API client, and primitives</name>
  <files>
    frontend/package.json
    frontend/tsconfig.json
    frontend/app.config.ts
    frontend/src/router.tsx
    frontend/src/client.tsx
    frontend/src/ssr.tsx
    frontend/src/routes/__root.tsx
    frontend/src/routes/index.tsx
    frontend/src/routes/login.tsx
    frontend/src/routes/_auth.tsx
    frontend/src/api/endpoints.ts
    frontend/src/lib/api-client.ts
    frontend/src/styles/overrides.css
    frontend/src/components/primitives/Button.tsx
    frontend/src/components/primitives/Badge.tsx
    frontend/src/components/primitives/Card.tsx
    frontend/src/components/primitives/Spinner.tsx
    frontend/src/components/primitives/Skeleton.tsx
    frontend/src/components/primitives/Modal.tsx
  </files>
  <action>
**Step 1: Scaffold TanStack Start**

Run `bun create @tanstack/start@latest frontend` from the project root. If interactive prompts block, create manually:

Create `frontend/package.json` with dependencies: `@tanstack/react-start` (^1.160.0), `@tanstack/react-router` (^1.160.0), `@tanstack/react-query` (^5.90.0), `react` (^19.0.0), `react-dom` (^19.0.0), `@knadh/oat` (latest), `@use-gesture/react` (^10.0.0), `@react-spring/web` (^9.0.0). Dev deps: `@types/bun`, `@vitejs/plugin-react`, `vite`, `vite-tsconfig-paths`, `typescript`. Scripts: `"dev": "vinxi dev"`, `"build": "vinxi build"`, `"start": "vinxi start"`.

NOTE: Check the scaffolded output from `bun create` carefully. TanStack Start v1.160.x may use either `vinxi` or `vite` as the dev command. If scaffolded output differs from above, follow the scaffolded structure. The key constraint is: server preset must be `bun`, and React 19 must be used.

After scaffolding, install additional deps: `bun add @tanstack/react-query @knadh/oat @use-gesture/react @react-spring/web` from frontend/.

**Step 2: Configure**

Set up `app.config.ts` (or `vite.config.ts` — follow whatever the scaffolded output uses) with:
- Server preset: `'bun'`
- React plugin
- TSConfig paths plugin

Create `frontend/tsconfig.json` with `@/` path alias mapping to `./src/`.

**Step 3: Router + QueryClient (router.tsx)**

Create `frontend/src/router.tsx` following research Pattern 2: `createRouter` with `routeTree` (from generated `routeTree.gen.ts`), `QueryClient` in router context with `staleTime: 30_000`, `retry: 1`. Export `getRouter` function. Add module declaration for `@tanstack/react-router` Register interface.

Create `frontend/src/client.tsx` as browser entry point — `hydrateRoot` with `RouterProvider`.
Create `frontend/src/ssr.tsx` as SSR entry point (if scaffolded structure requires it).

**Step 4: Root layout (__root.tsx)**

Create `frontend/src/routes/__root.tsx` following research Pattern 3:
- Import `@knadh/oat` CSS (check actual path in node_modules after install — likely `@knadh/oat/dist/oat.min.css` or `@knadh/oat/oat.css`)
- Import `../styles/overrides.css`
- Use `createRootRouteWithContext<{ queryClient: QueryClient }>()`
- Set `data-theme="dark"` on `<body>`
- Wrap `<Outlet />` with `<QueryClientProvider client={queryClient}>`
- Add meta tags: charset, viewport, title "GaiterGuard"

**Step 5: CSS overrides (overrides.css)**

Create `frontend/src/styles/overrides.css` with Vercel-style dark theme overrides for oat.ink CSS variables. Target: near-black backgrounds (#000 or #0a0a0a), subtle borders (#222), white text, blue accent (#0070f3), monospace code font. Override oat.ink's `--bg`, `--bg-alt`, `--text`, `--text-light`, `--accent`, `--border` CSS custom properties (inspect oat.ink source for exact variable names). Add global styles: `font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;`, `body { margin: 0; }`.

**Step 6: Auth flow**

Create `frontend/src/lib/api-client.ts` with:
- `getStoredToken()` / `setStoredToken(token)` / `clearStoredToken()` using localStorage key `access_token`
- `isAuthenticated()` returns boolean

Create `frontend/src/routes/login.tsx`:
- Login form with email + password fields using oat.ink semantic HTML (`<form>`, `<input>`, `<button>`)
- On submit, call `api.login(email, password)` from endpoints.ts
- On success, store token via `setStoredToken()`, navigate to `/queue`
- On error, show error message
- Use `frontend-design` skill for production-grade styling

Create `frontend/src/routes/_auth.tsx` following research Pattern 4:
- `beforeLoad` checks `getStoredToken()` — if falsy, `throw redirect({ to: '/login' })`
- Component: `<Outlet />`

Create `frontend/src/routes/index.tsx`:
- Redirect to `/queue` (the default authenticated view)

**Step 7: Centralized API client (endpoints.ts)**

Create `frontend/src/api/endpoints.ts` following research Pattern 7:
- `BACKEND_BASE` from `import.meta.env.VITE_BACKEND_URL ?? 'http://localhost:3000'`
- `authedFetch(path, init)` helper that adds `Authorization: Bearer {token}` and `Content-Type: application/json`, handles 401 by clearing token and redirecting to `/login`
- Export `api` object with ALL endpoints:
  - `login(email, password)` (no auth needed)
  - `listPendingApprovals()` -> GET /approvals/pending
  - `approveAction(actionId)` -> PATCH /approvals/{actionId}/approve
  - `denyAction(actionId)` -> PATCH /approvals/{actionId}/deny
  - `listServices()` -> GET /services
  - `createService(data)` -> POST /services
  - `updateService(id, data)` -> PUT /services/{id}
  - `deleteService(id)` -> DELETE /services/{id}
  - `upsertCredentials(id, data)` -> POST /services/{id}/credentials

**Step 8: Component primitives**

Create reusable components in `frontend/src/components/primitives/` using oat.ink semantic HTML (minimal classes). Use `frontend-design` skill for each. Vercel dark aesthetic.

- `Button.tsx` — wraps `<button>` with `data-variant` prop (primary, danger, ghost). Supports `loading` state with spinner.
- `Badge.tsx` — wraps `<span class="badge">` with `data-variant` prop (info, warning, danger, success). Used for risk scores, HTTP methods.
- `Card.tsx` — wraps `<article class="card">` with optional `<header>`, `<footer>` slots via children. Supports expandable state.
- `Spinner.tsx` — CSS-only loading spinner. Small and large variants.
- `Skeleton.tsx` — Animated placeholder for loading states. Accepts `width`, `height`, `lines` props.
- `Modal.tsx` — Dialog overlay using `<dialog>` element (oat.ink styles dialogs). `open`, `onClose` props. Renders via React portal.

Export all primitives from `frontend/src/components/primitives/index.ts` barrel file.
  </action>
  <verify>
Run `cd frontend && bun install && bun run dev` (or the equivalent dev command from package.json). Verify the app starts without build errors. Visit http://localhost:3000 (or whatever port TanStack Start uses) in a browser — should see the login page with dark theme. Check that navigating to / redirects to /login (no token). Verify primitives compile: `cd frontend && bunx tsc --noEmit`.
  </verify>
  <done>
TanStack Start frontend running in frontend/ with React 19, oat.ink dark theme (Vercel-style overrides), login page, auth guard on /_auth routes, centralized API client with all backend endpoints, and 6 reusable primitive components (Button, Badge, Card, Spinner, Skeleton, Modal). All TypeScript compiles. Dev server starts.
  </done>
</task>

</tasks>

<verification>
1. Backend: `bunx tsc --noEmit` in backend/ passes
2. Backend: Three new route handlers exported from dashboard.ts and wired in server.ts
3. Backend: CORS headers present in server.ts for frontend dev server
4. Frontend: `bun run dev` starts without errors
5. Frontend: Login page renders with dark theme at root URL
6. Frontend: Unauthenticated access to any /_auth route redirects to /login
7. Frontend: api/endpoints.ts exports api object with all 9 endpoint functions
8. Frontend: All 6 primitive components compile and export from barrel file
</verification>

<success_criteria>
- Backend has GET /approvals/pending, PATCH /approvals/:actionId/approve, PATCH /approvals/:actionId/deny
- Frontend dev server runs and shows login page with oat.ink dark theme
- Auth guard redirects unauthenticated users to /login
- Centralized API client has all backend endpoint functions
- 6 primitive components exist and compile
</success_criteria>

<output>
After completion, create `.planning/phases/06-dashboard/06-01-SUMMARY.md`
</output>
