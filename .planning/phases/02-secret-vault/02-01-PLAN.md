---
phase: 02-secret-vault
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/db/schema.ts
  - backend/src/config/env.ts
  - backend/src/services/encryption.service.ts
  - backend/src/middleware/validation.ts
  - backend/package.json
autonomous: true

must_haves:
  truths:
    - "Encryption service can encrypt a string and decrypt it back to the original"
    - "Encryption produces different ciphertext each time (unique IVs)"
    - "Decryption fails with clear error on tampered ciphertext"
    - "Server fails to start if ENCRYPTION_SECRET is missing or too short"
    - "Zod validation middleware rejects invalid request bodies with structured errors"
  artifacts:
    - path: "backend/src/services/encryption.service.ts"
      provides: "AES-256-GCM encrypt/decrypt with scrypt key derivation"
      exports: ["encrypt", "decrypt", "initEncryption"]
    - path: "backend/src/middleware/validation.ts"
      provides: "Zod-based request body validation"
      exports: ["validateBody"]
    - path: "backend/src/db/schema.ts"
      provides: "services, credentials, documentation tables"
      contains: "pgTable"
    - path: "backend/src/config/env.ts"
      provides: "ENCRYPTION_SECRET and ENCRYPTION_SALT env vars"
      contains: "ENCRYPTION_SECRET"
  key_links:
    - from: "backend/src/services/encryption.service.ts"
      to: "backend/src/config/env.ts"
      via: "reads ENCRYPTION_SECRET from env"
      pattern: "env\\.ENCRYPTION_SECRET"
    - from: "backend/src/db/schema.ts"
      to: "backend/src/db/schema.ts"
      via: "foreign keys from credentials/documentation to services"
      pattern: "references.*services\\.id"
---

<objective>
Database schema for services/credentials/documentation, AES-256-GCM encryption service, and Zod validation middleware.

Purpose: Establishes the data layer and security primitives that all subsequent vault operations depend on.
Output: Three new DB tables (migrated), encryption service, validation middleware, zod installed.
</objective>

<execution_context>
@/home/shashank/.claude/get-shit-done/workflows/execute-plan.md
@/home/shashank/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-secret-vault/02-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@backend/src/db/schema.ts
@backend/src/config/env.ts
@backend/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database schema and environment config</name>
  <files>backend/src/db/schema.ts, backend/src/config/env.ts, backend/package.json</files>
  <action>
1. Install zod: `cd backend && bun add zod`

2. Update `backend/src/config/env.ts` — add two new env vars:
   - `ENCRYPTION_SECRET`: required, string, validated to be at least 32 characters long. Throw descriptive error if too short.
   - `ENCRYPTION_SALT`: optional, defaults to `'gaiter-guard-salt-v1'`

3. Update `backend/src/db/schema.ts` — add three tables AFTER existing users/refreshTokens tables:

   **services table:**
   - id: integer, primaryKey, generatedAlwaysAsIdentity
   - userId: integer, references users.id, notNull
   - name: varchar(255), notNull
   - baseUrl: varchar(512), notNull
   - authType: varchar(50), notNull (stores: 'api_key', 'bearer', 'basic', 'oauth2')
   - createdAt: timestamp, defaultNow, notNull
   - updatedAt: timestamp, defaultNow, notNull
   - Index on userId: `services_user_id_idx`

   **credentials table:**
   - id: integer, primaryKey, generatedAlwaysAsIdentity
   - serviceId: integer, references services.id with onDelete 'cascade', notNull
   - key: varchar(255), notNull (e.g., 'api_key', 'username', 'password')
   - encryptedValue: text, notNull (stores iv:authTag:ciphertext format)
   - createdAt: timestamp, defaultNow, notNull
   - updatedAt: timestamp, defaultNow, notNull
   - Index on serviceId: `credentials_service_id_idx`

   **documentation table:**
   - id: integer, primaryKey, generatedAlwaysAsIdentity
   - serviceId: integer, references services.id with onDelete 'cascade', notNull
   - type: varchar(50), notNull ('openapi', 'markdown', 'url')
   - title: varchar(255) (optional, for display)
   - content: text, notNull (JSON string for OpenAPI, markdown text, or URL string)
   - createdAt: timestamp, defaultNow, notNull
   - updatedAt: timestamp, defaultNow, notNull
   - Index on serviceId: `documentation_service_id_idx`

   Export inferred types: Service, InsertService, Credential, InsertCredential, Documentation, InsertDocumentation.

4. Generate and run migration:
   ```bash
   cd backend && bun run db:generate && bun run db:migrate
   ```

IMPORTANT: Keep existing users and refreshTokens tables exactly as-is. Only ADD new tables and types.
  </action>
  <verify>
Run `cd backend && bun run db:generate` succeeds. Run `cd backend && bun run db:migrate` succeeds. Verify the three new tables exist by checking the generated migration SQL contains CREATE TABLE for services, credentials, documentation.
  </verify>
  <done>Three new tables (services, credentials, documentation) exist in the database with correct foreign keys and cascade deletes. ENCRYPTION_SECRET is a required env var validated at startup. Zod is installed.</done>
</task>

<task type="auto">
  <name>Task 2: Encryption service and validation middleware</name>
  <files>backend/src/services/encryption.service.ts, backend/src/middleware/validation.ts</files>
  <action>
1. Create `backend/src/services/encryption.service.ts`:
   - Import createCipheriv, createDecipheriv, randomBytes, scryptSync from 'node:crypto'
   - Import env from '@/config/env'
   - Constants: ALGORITHM = 'aes-256-gcm', KEY_LENGTH = 32, IV_LENGTH = 16
   - `initEncryption()`: derives key using scryptSync(env.ENCRYPTION_SECRET, env.ENCRYPTION_SALT, KEY_LENGTH). Store in module-level variable. Call this at server startup.
   - `encrypt(plaintext: string): string`: generate random IV (16 bytes), create cipher, encrypt, get auth tag, return `${iv.toString('hex')}:${authTag.toString('hex')}:${encrypted}` format. Throw if encryption not initialized.
   - `decrypt(ciphertext: string): string`: split on ':', reconstruct IV and auth tag from hex, create decipher, set auth tag, decrypt. Wrap in try/catch — on failure throw "Decryption failed: data may be corrupted or tampered". Throw if encryption not initialized.
   - Follow the exact pattern from 02-RESEARCH.md "Complete Encryption/Decryption with Error Handling" section.

2. Create `backend/src/middleware/validation.ts`:
   - Import z from 'zod'
   - Import errorResponse from '@/utils/responses'
   - Export `validateBody<T extends z.ZodSchema>(schema: T)` function that:
     - Takes a Request, calls req.json()
     - Runs schema.safeParse(body)
     - If success: returns typed data as z.infer<T>
     - If failure: throws a ValidationError with formatted Zod issues
   - Export `ValidationError` class extending Error with:
     - statusCode: 400
     - issues: array of Zod formatted errors
     - message: first error message for convenience

Note: Do NOT call initEncryption() from server.ts yet — that will happen in Plan 02 when routes are wired.
Actually, DO add the initEncryption() call to server.ts right before Bun.serve() so the encryption key is ready. Import initEncryption from the encryption service.
  </action>
  <verify>
Write a quick test: create a temporary script `backend/scripts/test-encryption.ts` that imports encrypt/decrypt, calls initEncryption(), encrypts "test-secret", decrypts it, and verifies the result matches. Run it with `cd backend && bun run scripts/test-encryption.ts`. Also verify encrypting the same value twice produces different ciphertext (unique IVs). Delete the test script after verification.
  </verify>
  <done>encrypt("hello") produces iv:authTag:ciphertext format, decrypt() recovers "hello", encrypting same value twice gives different ciphertext, tampered ciphertext throws error, ValidationError class works with Zod schemas, initEncryption() called at server startup.</done>
</task>

</tasks>

<verification>
1. `cd backend && bun run start` boots without errors (ENCRYPTION_SECRET must be set in .env)
2. Database has services, credentials, documentation tables with correct foreign keys
3. Encryption round-trip works (encrypt then decrypt returns original)
4. Unique IV per encryption (same input, different output)
</verification>

<success_criteria>
- Three database tables created and migrated
- ENCRYPTION_SECRET validated at startup
- AES-256-GCM encryption/decryption working with unique IVs
- Zod validation middleware ready for use
- Server starts successfully with new dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/02-secret-vault/02-01-SUMMARY.md`
</output>
