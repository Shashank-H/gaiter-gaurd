---
phase: 02-secret-vault
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - backend/src/services/service.service.ts
  - backend/src/routes/services.ts
  - backend/src/server.ts
  - backend/src/utils/masking.ts
autonomous: true

must_haves:
  truths:
    - "User can create a service with name, baseUrl, authType, and credentials via POST /services"
    - "User can list their own services via GET /services (not other users' services)"
    - "User can get a single service via GET /services/:id (only their own)"
    - "User can update service details via PUT /services/:id"
    - "User can delete a service via DELETE /services/:id (cascade deletes credentials)"
    - "User can add/replace credentials via POST /services/:id/credentials"
    - "Credentials are NEVER returned in any API response"
    - "API responses indicate credential presence but not values"
  artifacts:
    - path: "backend/src/services/service.service.ts"
      provides: "Service CRUD with transparent encryption"
      exports: ["createService", "getServicesByUser", "getServiceById", "updateService", "deleteService", "upsertCredentials"]
    - path: "backend/src/routes/services.ts"
      provides: "REST endpoints for service management"
      exports: ["handleCreateService", "handleListServices", "handleGetService", "handleUpdateService", "handleDeleteService", "handleUpsertCredentials"]
    - path: "backend/src/utils/masking.ts"
      provides: "Credential masking for safe API responses"
      exports: ["maskCredential", "formatServiceResponse"]
  key_links:
    - from: "backend/src/routes/services.ts"
      to: "backend/src/middleware/auth.ts"
      via: "requireAuth for all endpoints"
      pattern: "requireAuth"
    - from: "backend/src/services/service.service.ts"
      to: "backend/src/services/encryption.service.ts"
      via: "encrypt() on credential write, never decrypt in responses"
      pattern: "encrypt\\("
    - from: "backend/src/server.ts"
      to: "backend/src/routes/services.ts"
      via: "route registration with parameterized path matching"
      pattern: "handleCreateService|handleListServices"
---

<objective>
Complete service CRUD with encrypted credentials — register services, store API keys encrypted, edit/delete services.

Purpose: Implements VAULT-01 (service registration), VAULT-02 (encrypted credentials), and VAULT-04 (edit/delete).
Output: Full REST API for service management with credential encryption.
</objective>

<execution_context>
@/home/shashank/.claude/get-shit-done/workflows/execute-plan.md
@/home/shashank/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-secret-vault/02-RESEARCH.md
@.planning/phases/02-secret-vault/02-01-SUMMARY.md
@backend/src/server.ts
@backend/src/db/schema.ts
@backend/src/middleware/auth.ts
@backend/src/services/encryption.service.ts
@backend/src/middleware/validation.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Service service layer and masking utility</name>
  <files>backend/src/services/service.service.ts, backend/src/utils/masking.ts</files>
  <action>
1. Create `backend/src/utils/masking.ts`:
   - `maskCredential(value: string): string` — if length <= 8 return '***', else return first 4 chars + '***' + last 4 chars. NOTE: This is only for internal/admin use. API responses should NEVER contain even masked credential values.
   - `formatServiceResponse(service, credentialKeys?: string[])` — returns service object with `credentials` field replaced by `{ keys: ['api_key', 'secret'], count: 2 }` (shows WHICH credential keys exist, not their values). Never include encryptedValue or decrypted value.

2. Create `backend/src/services/service.service.ts`:
   - Import db, schema tables, encrypt from encryption.service, eq/and from drizzle-orm
   - Define Zod schemas at top of file (or in a separate schemas file — your call, but keep it close):
     - `createServiceSchema`: name (string 1-255), baseUrl (string url max 512), authType (enum: 'api_key', 'bearer', 'basic', 'oauth2'), credentials (record of string to string, at least 1 entry, no empty values)
     - `updateServiceSchema`: name, baseUrl, authType all optional (partial of create minus credentials), at least one field present
     - `credentialsSchema`: record of string to string, at least 1 entry, no empty values

   - `createService(userId, data)`:
     - Use db.transaction — insert into services table, then encrypt each credential value and insert into credentials table
     - Return service object (WITHOUT credentials)

   - `getServicesByUser(userId)`:
     - Select all services where userId matches
     - For each service, query credential keys (just the `key` column, NOT encryptedValue)
     - Return array of services with credential key names attached

   - `getServiceById(serviceId, userId)`:
     - Select service where id AND userId match (ownership check)
     - If not found, throw NotFoundError
     - Query credential keys for this service
     - Return service with credential key names

   - `updateService(serviceId, userId, data)`:
     - Verify ownership (select where id AND userId match)
     - If not found, throw NotFoundError
     - Update service fields, explicitly set updatedAt to new Date()
     - Return updated service

   - `deleteService(serviceId, userId)`:
     - Verify ownership first
     - Delete service (cascade handles credentials and documentation)
     - Return { deleted: true }

   - `upsertCredentials(serviceId, userId, credentials: Record<string, string>)`:
     - Verify service ownership
     - Use transaction: delete ALL existing credentials for this service, then insert new ones (replace semantics per research recommendation)
     - Encrypt each value before insert
     - Return { keys: Object.keys(credentials), count: Object.keys(credentials).length }

   - Export a `NotFoundError` class extending Error with statusCode 404.

CRITICAL: The decrypt() function should NEVER be called in any route handler or service method that returns data to the user. Decrypt is ONLY for internal use when injecting credentials into outbound proxy requests (Phase 4). In this phase, no decryption happens in response paths.
  </action>
  <verify>
TypeScript compilation check: `cd backend && bun build src/services/service.service.ts --no-bundle --outdir /tmp/check` should succeed without type errors. Verify the file does NOT contain any call to decrypt() in functions that return data.
  </verify>
  <done>Service CRUD functions implemented with transactional credential encryption. No credential values ever returned. Ownership checks on all operations. Zod schemas defined for validation.</done>
</task>

<task type="auto">
  <name>Task 2: Service routes and server wiring</name>
  <files>backend/src/routes/services.ts, backend/src/server.ts</files>
  <action>
1. Create `backend/src/routes/services.ts` with these handlers (all require authentication via requireAuth):

   - `handleCreateService(req)`: POST /services
     - requireAuth, validateBody with createServiceSchema
     - Call createService(userId, data)
     - Return 201 with formatted service response (formatServiceResponse)

   - `handleListServices(req)`: GET /services
     - requireAuth
     - Call getServicesByUser(userId)
     - Return 200 with array of formatted service responses

   - `handleGetService(req, params)`: GET /services/:id
     - requireAuth, parse id from params
     - Call getServiceById(id, userId)
     - Return 200 with formatted service response

   - `handleUpdateService(req, params)`: PUT /services/:id
     - requireAuth, validateBody with updateServiceSchema, parse id from params
     - Call updateService(id, userId, data)
     - Return 200 with formatted service response

   - `handleDeleteService(req, params)`: DELETE /services/:id
     - requireAuth, parse id from params
     - Call deleteService(id, userId)
     - Return 200 with { message: 'Service deleted' }

   - `handleUpsertCredentials(req, params)`: POST /services/:id/credentials
     - requireAuth, validateBody with credentialsSchema, parse id from params
     - Call upsertCredentials(id, userId, data)
     - Return 200 with { message: 'Credentials updated', keys, count }

   Error handling pattern (same as auth.ts): catch AuthError (401), ValidationError (400), NotFoundError (404), generic (500). NEVER log error objects that might contain credential data — only log error.message.

2. Update `backend/src/server.ts` to support parameterized routes:
   - The current router uses exact-match `routes[routeKey]`. It needs to handle `/services/:id` and `/services/:id/credentials` patterns.
   - Approach: Add a `paramRoutes` array of `{ method, pattern: RegExp, handler, paramNames }` entries checked AFTER exact match fails.
   - OR simpler: parse the pathname manually — if it starts with `/services`, extract segments and route accordingly.
   - Recommended: Add a small helper that matches `/services`, `/services/:id`, `/services/:id/credentials` patterns. Keep it simple — no full router library needed.
   - Register the service route handlers.
   - Keep existing exact-match routes for health and auth endpoints.

   Example parameterized routing approach:
   ```
   // After exact match fails, try parameterized routes
   if (pathname === '/services' && method === 'GET') return handleListServices(req);
   if (pathname === '/services' && method === 'POST') return handleCreateService(req);
   const serviceMatch = pathname.match(/^\/services\/(\d+)$/);
   if (serviceMatch) {
     const params = { id: serviceMatch[1] };
     if (method === 'GET') return handleGetService(req, params);
     if (method === 'PUT') return handleUpdateService(req, params);
     if (method === 'DELETE') return handleDeleteService(req, params);
   }
   const credMatch = pathname.match(/^\/services\/(\d+)\/credentials$/);
   if (credMatch) {
     const params = { id: credMatch[1] };
     if (method === 'POST') return handleUpsertCredentials(req, params);
   }
   ```
  </action>
  <verify>
Start the server (`cd backend && bun run dev` or `bun run start`) and test with curl:
1. Register + login to get access token
2. `curl -X POST /services` with valid body and Bearer token — expect 201, response has NO credential values
3. `curl -X GET /services` — expect 200 with array, credentials shown as { keys: [...], count: N }
4. `curl -X GET /services/1` — expect 200 with single service
5. `curl -X PUT /services/1` with partial update — expect 200
6. `curl -X POST /services/1/credentials` with new credentials — expect 200
7. `curl -X DELETE /services/1` — expect 200
8. `curl -X GET /services/1` after delete — expect 404
9. Try accessing another user's service — expect 404 (not 403, to avoid leaking existence)
  </verify>
  <done>All service CRUD endpoints working with authentication. Credentials encrypted on write, never returned in responses. Ownership enforced on all operations. Server routing handles parameterized paths.</done>
</task>

</tasks>

<verification>
1. POST /services creates service with encrypted credentials in database
2. GET /services returns only the authenticated user's services
3. GET /services/:id returns 404 for other users' services (ownership check)
4. PUT /services/:id updates service details, sets updatedAt
5. DELETE /services/:id cascade-deletes credentials
6. POST /services/:id/credentials replaces all credentials (encrypted)
7. NO endpoint returns credential values — only key names and count
8. Direct database inspection shows credentials.encryptedValue is in iv:authTag:ciphertext format
</verification>

<success_criteria>
- Full service CRUD via REST API
- All endpoints require JWT authentication
- Credentials encrypted with AES-256-GCM before storage
- Credential values never appear in any API response
- Ownership enforced: users can only access their own services
- Cascade delete removes credentials when service is deleted
</success_criteria>

<output>
After completion, create `.planning/phases/02-secret-vault/02-02-SUMMARY.md`
</output>
